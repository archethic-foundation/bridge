var d=Object.defineProperty;var h=(i,e,t)=>e in i?d(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t;var o=(i,e,t)=>(h(i,typeof e!="symbol"?e+"":e,t),t);import{bY as w,au as p,at as g}from"../main.js";import{A as u}from"./aptos-Ckf6jj2W.js";import{c as l}from"./create-BFgMQumI.js";import{r as f}from"./chain-bpRy55lx.js";class c{constructor(e,t,r,s){o(this,"network");o(this,"chain");o(this,"connection");o(this,"contracts");o(this,"chainId");o(this,"coreBridge");this.network=e,this.chain=t,this.connection=r,this.contracts=s,this.chainId=w(t);const n=s.coreBridge;if(!n)throw new Error(`CoreBridge contract Address for chain ${t} not found`);this.coreBridge=n}getGuardianSet(e){throw new Error("Method not implemented.")}getGuardianSetIndex(){throw new Error("Method not implemented.")}getMessageFee(){throw new Error("Method not implemented.")}static async fromRpc(e,t){const[r,s]=await u.chainFromRpc(e),n=t[s];if(n.network!==r)throw new Error(`Network mismatch: ${n.network} !== ${r}`);return new c(r,s,e,n.contracts)}async*publishMessage(e,t){throw new Error("Method not implemented.")}async*verifyMessage(e,t){throw new Error("Not implemented.")}async parseTransaction(e){return(await this.parseMessages(e)).map(r=>({chain:r.emitterChain,emitter:r.emitterAddress,sequence:r.sequence}))}async parseMessages(e){const t=await this.connection.getTransactionByHash(e);if(t.type!=="user_transaction")throw new Error(`${e} is not a user_transaction`);const s=t.events.filter(n=>n.type.endsWith("WormholeMessage"));if(!s||s.length===0)throw new Error(`WormholeMessage not found for ${e}`);return s.map(n=>{const a=n.data,m=new p(BigInt(a.sender).toString(16).padStart(64,"0"));return l("Uint8Array",{guardianSet:0,emitterChain:this.chain,emitterAddress:m,sequence:BigInt(a.sequence),timestamp:Number(a.timestamp),consistencyLevel:a.consistency_level,nonce:Number(a.nonce),signatures:[],payload:g.decode(a.payload)})})}}f("Aptos","WormholeCore",c);export{c as AptosWormholeCore};
