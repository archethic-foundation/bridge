var p=Object.defineProperty;var u=(o,t,i)=>t in o?p(o,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):o[t]=i;var e=(o,t,i)=>(u(o,typeof t!="symbol"?t+"":t,i),i);import{ci as d,ay as f,az as m,cj as w,ck as k,cl as B}from"../main.js";function P(o){return"getVersion"in o}const s={};function R(o,t,i){t in s||(s[t]={});const r=s[t];if(o in r)throw new Error(`Protocol ${o} for protocol ${t} has already registered`);s[t][o]=i}function C(o,t){const i=d(o)?f.get(o):o;return t in s?i in s[t]:!1}function g(o,t){if(t in s){const i=s[t];if(i&&o in i){const r=i[o];if(r)return r}}throw new Error(`No protocols registered for ${o}:${t}. This may be because the platform specific protocol implementation is not registered (by installing and importing it) or no implementation exists for this platform`)}const T=(o,t,i,r)=>g(o,t).fromRpc(i,r);class W{constructor(t,i){e(this,"network");e(this,"config");this.network=t,this.config=i}utils(){return this.constructor}getProtocol(t,i){return T(this.utils()._platform,t,i,this.config)}getProtocolInitializer(t){return g(this.utils()._platform,t)}async parseWormholeMessages(t,i,r){return(await this.getProtocol("WormholeCore",i)).parseTransaction(r)}}class I{constructor(t,i,r){e(this,"network");e(this,"chain");e(this,"config");e(this,"platform");e(this,"rpc");e(this,"protocols",new Map);e(this,"supportsWormholeCore",()=>this.supportsProtocol("WormholeCore"));e(this,"getWormholeCore",()=>this.getProtocol("WormholeCore"));e(this,"supportsTokenBridge",()=>this.supportsProtocol("TokenBridge"));e(this,"getTokenBridge",()=>this.getProtocol("TokenBridge"));e(this,"supportsAutomaticTokenBridge",()=>this.supportsProtocol("AutomaticTokenBridge"));e(this,"getAutomaticTokenBridge",()=>this.getProtocol("AutomaticTokenBridge"));e(this,"supportsCircleBridge",()=>this.supportsProtocol("CircleBridge"));e(this,"getCircleBridge",()=>this.getProtocol("CircleBridge"));e(this,"supportsAutomaticCircleBridge",()=>this.supportsProtocol("AutomaticCircleBridge"));e(this,"getAutomaticCircleBridge",()=>this.getProtocol("AutomaticCircleBridge"));e(this,"supportsIbcBridge",()=>this.supportsProtocol("IbcBridge"));e(this,"getIbcBridge",()=>this.getProtocol("IbcBridge"));e(this,"supportsPorticoBridge",()=>this.supportsProtocol("PorticoBridge"));e(this,"getPorticoBridge",()=>this.getProtocol("PorticoBridge"));this.config=i.config[t],this.platform=i,this.chain=this.config.key,this.network=this.config.network,this.rpc=r}getRpc(){return this.rpc=this.rpc?this.rpc:this.platform.getRpc(this.chain),this.rpc}async getDecimals(t){if(m(t))return this.config.nativeTokenDecimals;if(this.config.tokenMap){const i=w({chain:this.chain,address:t}),r=k(this.network,this.chain,i);if(r)return r.decimals}return this.platform.utils().getDecimals(this.chain,await this.getRpc(),t)}async getBalance(t,i){return this.platform.utils().getBalance(this.chain,await this.getRpc(),t,i)}async getLatestBlock(){return this.platform.utils().getLatestBlock(await this.getRpc())}async getLatestFinalizedBlock(){return this.platform.utils().getLatestFinalizedBlock(await this.getRpc())}async parseTransaction(t){return this.platform.parseWormholeMessages(this.chain,await this.getRpc(),t)}async sendWait(t){return this.platform.utils().sendWait(this.chain,await this.getRpc(),t)}getToken(t){if(this.config.tokenMap&&t in this.config.tokenMap)return this.config.tokenMap[t]}async getNativeWrappedTokenId(){if(this.config.wrappedNative){const{address:i}=this.config.wrappedNative;return{chain:this.chain,address:B(this.chain,i)}}const t=await this.getTokenBridge();return{chain:this.chain,address:await t.getWrappedNative()}}async getTokenAccount(t,i){return{chain:this.chain,address:t}}supportsProtocol(t){return C(this.chain,t)}async getProtocol(t,i,r){if(!i&&this.protocols.has(t))return this.protocols.get(t);const n=i?{...this.config.contracts,...i}:this.config.contracts,a=r??await this.getRpc(),h=this.platform.getProtocolInitializer(t);let c;if(r){if(i)throw new Error("Custom contracts are currently not supported with custom rpc connection. Add the contracts to the base config.");c=await this.platform.getProtocol(t,a)}else if(P(h)){const l=await h.getVersion(a,n);c=new h(this.network,this.chain,a,n,l)}else c=new h(this.network,this.chain,a,n);return i||this.protocols.set(t,c),c}}export{I as C,W as P,R as r};
